<!doctype html>
<html>

<head>
    <title>JJBotBot</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            /* box-sizing: border-box; */
        }

        /*temp border*/
        /* div {
            border: 1px red;
            border-style: dashed;
        } */

        html {
            height: 100%;
        }

        body {
            height: 100%;
            line-height: 1.6;
            font-family: "Inter", "Roobert", "Helvetica Neue", Helvetica, Arial, sans-serif;
            font-size: 18px;
            background-color: #202020;
            color: white;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            line-height: 1.2;
            font-family: "Roobert", "Inter", "Helvetica Neue", Helvetica, Arial, sans-serif;
        }

        #app {
            margin: 0px 10px;
        }

        #login {
            position: fixed;
            top: 0;
            right: 0;
            z-index: 1;
            border: 1px solid white;
            /* padding: 2px 0px 0px 2px; */
            margin: 0px 1px;
            height: 30px;
            background: #282828;
        }

        #login img {
            height: 30px;
        }

        #super_admin {
            border: 1px solid red;
            border-radius: 5px;
            background-color: #611;
            padding: 4px 4px 0px 4px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
        }

        #left_container {
            width: 50%;
        }

        #nicknames {
            list-style-type: none;
            font-weight: bold;
            padding: 10px;
        }

        #nicknames_container {
            width: 50%;
        }

        .edit {
            font-size: larger;
            color: white;
        }

        .delete {
            color: white;
        }

        .nickname {
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            /* font-size: smaller; */
        }

        .equals {
            color: white
        }

        .pronoun {
            padding: 0.5px;
            margin-right: 4px;
            font-weight: bold;
            border-radius: 5px;
            font-size: smaller;
            border: 1px solid lightgray;
        }

        #chat {
            width: 50%;
            height: 100%;
            float: right;
            right: 0;
            top: 0;
            position: fixed;
            background: #101010;
        }

        #chat-header {
            height: 125px;
            padding: 0px 10px;
        }

        #messages {
            list-style-type: none;
            margin: 0;
            padding: 2px 0;
            height: 100%;
            height: calc(100vh - 125px - 4px);
            overflow-y: scroll;
            word-wrap: break-word;
            background: #101010;
        }

        #messages li {
            padding: 2px 10px;
        }

        /* #messages li:nth-child(odd) {
            background: #eee;
        } */

        a:link {
            color: #36c;
        }

        a:visited {
            color: #94f;
        }

        .right {
            float: right;
        }

        .nowrap {
            white-space: nowrap;
        }

        .alert {
            padding: 5px;
            margin-right: 10px;
        }

        .red-bg {
            color: white;
            background-color: #d22;
        }

        .green-bg {
            color: white;
            background-color: #292;
        }

        .gray-bg {
            color: white;
            background-color: #444;
        }

        .red {
            color: #d22;
            background-color: white;
        }

        .green {
            color: #292;
            background-color: white;
        }

        .bold {
            font-weight: bold;
        }

        .rounded {
            padding: 2px;
            border-radius: 8px;
        }

        .emote {
            margin: -.75rem 0;
            height: 2.2rem;
        }

        .button {
            font-weight: bold;
            border: 1px solid white;
            border-radius: 8px;
            padding: 2px;
            background-color: #282828;
            text-decoration: none;
        }

        button:disabled,
        button[disabled] {
            background-color: #aaa;
            color: #555;
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="login" v-if="!is_chat_fullscreen">
            <span v-if="loggedIn">
                <a v-if="login !== channel" :href="'/' + login"><img :src="profile_image_url" /></a>
                <img v-else :src="profile_image_url" />
                <div class="right">
                    &nbsp;
                    <a v-if="login !== channel" :href="'/' + login">[[display_name]]</a>
                    <span v-else>[[display_name]]</span>
                    <span v-if="is_super_admin">&nbsp;<span id="super_admin">SUPER ADMIN</span></span>
                    &nbsp;
                    <a href="/api/logout?returnTo={{channel}}">log out</a>
                    &nbsp;
                </div>
            </span>
            <span v-else>
                &nbsp;
                for streamers:
                <a href="/api/auth/twitch">log in</a>
                &nbsp;
            </span>
        </div>
        <div id="left_container" v-if="!is_chat_fullscreen">
            <a href="/">
                <h1>JJBotBot</h1>
            </a>
            <p v-if="channels">
                Channel:
                <select v-model="channel">
                    <option selected :value="channel">[[ channel ]]</option>
                    <option v-if="loggedIn && channel !== login" :value="login">[[ login ]]</option>
                    <option v-for="c in channels.filter(c => c !== channel && c !== login)" :value="c">[[ c ]]</option>
                </select>
                <button @click="custom_channel">custom</button>
            </p>
            <p v-else>
                Loading...
            </p>
            <span v-if="loggedIn && channels">
                <span v-if="channel === login || is_super_admin">
                    <p v-if="channel_props.enabled" class="alert green-bg">
                        The bot is enabled on <span v-if="channel === login">your</span><span v-else>this</span> channel
                        ([[ channel ]]). <button class="red bold rounded" :disabled="enabled_grayed_out"
                            @click="set_enabled(false)">DISABLE</button>
                    </p>
                    <p v-else class="alert red-bg">The bot is NOT enabled on <span
                            v-if="channel === login">your</span><span v-else>this</span> channel ([[ channel ]]).
                        <button class="red bold rounded" :disabled="enabled_grayed_out"
                            @click="set_enabled(true)">ENABLE</button>
                    </p>

                    <span v-if="channel_props.youtube_id && channel_props.youtube_id.length > 0">
                        youtube channel connected:
                        <a :href="'https://www.youtube.com/channel/' + channel_props.youtube_id">
                            [[channel_props.youtube_id ]]
                        </a>
                        <button @click="set_channel_prop('youtube_id', undefined)">disconnect</button>
                    </span>
                    <span v-else>
                        no youtube channel connected - enter youtube channel URL or ID:
                        <input type="text" v-model="youtube_input" />
                        <button @click="find_youtube_id">find channel</button>
                    </span>
                    <button @click="check_youtube_status">check youtube chat status</button>
                    </p>
                    <p>
                        <span v-if="channel_props.owncast_url && channel_props.owncast_url.length > 0">
                            owncast connected:
                            <a :href="'https://' + channel_props.owncast_url">[[ channel_props.owncast_url ]]</a>
                            <button @click="set_channel_prop('owncast_url', undefined)">disconnect</button>
                        </span>
                        <span v-else>
                            owncast not connected - enter owncast URL:
                            <input type="text" v-model="owncast_input" />
                            <button @click="set_owncast_url(owncast_input)">connect</button>
                        </span>
                        <button @click="check_owncast_status">check owncast chat status</button>
                    </p>
                    <p>
                        <span v-if="channel_props.kick_chatroom_id && channel_props.kick_chatroom_id.length > 0">kick
                            connected:
                            <a :href="'https://kick.com/' + channel_props.kick_username">[[ channel_props.kick_username
                                ]] ([[ channel_props.kick_chatroom_id
                                ]])</a>
                            <button @click="kick_disconnect">disconnect</button>
                        </span>
                        <span v-else>
                            kick not connected - enter kick username: <input type="text" v-model="kick_input" />
                            <button @click="kick_connect">connect</button>
                        </span>
                        <button @click="check_kick_status">check kick chat status</button>
                    </p>
                    <p>
                        <button @click="check_emotes_status">check 3rd party emotes status</button>
                        <button @click="clear_chat">clear chat</button>
                    </p>
                    <h2>Forward Commands from Youtube to Twitch</h2>
                    <ul>
                        <li v-for="cmd, i in channel_props_edit.fwd_cmds_yt_twitch">
                            <span v-if="editing_fwd_idx === i">
                                <input type="text" v-model="editing_fwd_item" />
                                <button
                                    @click="channel_props_edit.fwd_cmds_yt_twitch[i] = editing_fwd_item; editing_fwd_idx = undefined; save_channel_prop('fwd_cmds_yt_twitch')">done</button>
                            </span>
                            <span v-else class="edit" v-if="loggedIn && channel === login || is_super_admin"
                                @click="editing_fwd_idx = i; editing_fwd_item = cmd">✎ [[cmd]]
                            </span>
                            <span class="delete"
                                @click="channel_props_edit.fwd_cmds_yt_twitch.splice(i, 1); save_channel_prop('fwd_cmds_yt_twitch')">
                                ⓧ</span>
                        </li>
                        <li><button
                                @click="channel_props_edit.fwd_cmds_yt_twitch.push(new_cmd); new_cmd = ''; save_channel_prop('fwd_cmds_yt_twitch')">
                                add new:</button><input type="text" v-model="new_cmd" /></li>
                    </ul>
                </span>
                <span v-else>
                    <p class="alert gray-bg">
                        logged in as
                        <a :href="'/' + login">[[ login ]]</a>,
                        viewing <span class="bold">[[ channel ]]</span>
                    </p>
                </span>
            </span>
            <span v-if="channel && channels">
                <h2>Nickname Ledger</h2>
                <span v-if="channel === login || is_super_admin">
                    max nickname length: <input v-model="channel_props_edit.max_nickname_length" type="number"> <button
                        @click="save_channel_prop('max_nickname_length')"
                        v-if="channel_props_edit.max_nickname_length !== channel_props.max_nickname_length"
                        class="red-bg rounded">save</button><br />
                    greetz threshold: <input v-model="channel_props_edit.greetz_threshold" type="number"> <button
                        @click="save_channel_prop('greetz_threshold')"
                        v-if="channel_props_edit.greetz_threshold !== channel_props.greetz_threshold"
                        class="red-bg rounded">save</button><br />
                    greetz wb threshold: <input v-model="channel_props_edit.greetz_wb_threshold" type="number"> <button
                        @click="save_channel_prop('greetz_wb_threshold')"
                        v-if="channel_props_edit.greetz_wb_threshold !== channel_props.greetz_wb_threshold"
                        class="red-bg rounded">save</button><br />
                </span>
                <span v-if="channel_props.enabled">
                    <p v-if="channel === login || is_super_admin" class="alert gray-bg">
                        Use <code>!setnickname</code> in the chat to show up here!
                    </p>
                    <p v-else class="alert green-bg">
                        Use <code>!setnickname</code> in [[ channel ]]'s chat to show up here!
                    </p>
                </span>
                <p v-else-if="!(channel === login || is_super_admin)" class="alert red-bg">
                    The bot is NOT enabled on this channel ([[ channel ]]), ask the streamer to enable it by
                    visiting this page and logging in.
                </p>
                <ul id="nicknames">
                    <li v-for="username in Object.keys(viewers)" :style="{ color: get_user_color(username) }">
                        <span v-if="editing_username === username">
                            <input v-model="editing_nickname">
                            <button @click="save_nickname">done</button>
                        </span>
                        <span v-else>
                            <span class="edit" v-if="loggedIn && channel === login || is_super_admin"
                                @click="editing_nickname = viewers[username].nickname; editing_username = username">✎
                            </span>
                            <span class="nickname">[[viewers[username].nickname]]</span>
                        </span>
                        <span class="equals"> = </span>
                        <span class="username">[[username]]</span>
                        <span class="delete" v-if="loggedIn && channel === login || is_super_admin">
                            &nbsp;<button class="custom_greetz" @click="set_custom_greetz(username)">custom greetz
                                ([[ viewers[username].custom_greetz ?? 'none set' ]])</button>
                            <span class="delete" @click="delete_viewer(username)"> ⓧ</span>
                        </span>
                    </li>
                    <li v-if="loggedIn && channel === login || is_super_admin">
                        <input v-model="new_nickname" style="width: 100px">
                        <span class="equals"> = </span>
                        <input v-model="new_username">
                        <button @click="add_nickname">&nbsp; + &nbsp;</button>
                        (case sensitive)
                    </li>
                </ul>
            </span>
        </div>

        <div :id="is_chat_fullscreen ? 'chat_fullscreen' : 'chat'">
            <div id="chat-header" v-if="!is_chat_fullscreen">
                <br />
                <h2 style="display:inline">Chat</h2>
                &nbsp;
                <a class="button" target="_blank"
                    :href="'/{{channel}}/chat?show_usernames=' + show_usernames + '&show_nicknames=' + show_nicknames + '&show_pronouns=' + show_pronouns">
                    pop-out
                    <img style="width:20px" src="/{{channel}}/external-link-ltr-icon.svg" alt="popout chat" />
                </a><br />
                show:
                <label class="nowrap"><input type="checkbox" v-model="show_usernames">usernames</label>&nbsp;
                <label class="nowrap"><input type="checkbox" v-model="show_nicknames">nicknames</label>&nbsp;
                <label class="nowrap"><input type="checkbox" v-model="show_pronouns">pronouns</label>
            </div>
            <ul id="messages"
                :style="is_chat_fullscreen ? { 'background-color': [[ bgcolor ]], 'height': '100vh', 'overflow': 'hidden' } : {}">
                <li v-for="msg in chat">
                    <!-- TODO: get the correct username color from youtube -->
                    <span class="bold" :style="{ color: get_user_color(msg.username) }">
                        <span v-if="show_pronouns && msg.pronouns" class="pronoun"
                            :style="{ 'border-color': get_user_color(msg.username) }">
                            [[ msg.pronouns ]]
                        </span>
                        <span v-if="show_usernames || !(show_nicknames && msg.nickname)">[[ msg.username ]]</span>
                        <span v-if="show_nicknames && msg.nickname">
                            <span v-if="show_usernames"> (<span class="nickname">[[msg.nickname]]</span>)</span>
                            <span v-else> <span class="nickname">[[msg.nickname]]</span></span>
                        </span>
                    </span>
                    <span>: </span>
                    <span v-if="msg.emotes">
                        <span v-for="{ type, value, raw } in myParseEmotesInMessage(msg.emotes, msg.text)">
                            <span v-if="type === 'emote'">
                                <img class="emote" :src="myGetEmoteAsUrl(value)" :alt="raw" :title="raw" />
                            </span>
                            <span v-else>[[ value ]]</span>
                        </span>
                    </span>
                    <span v-else>[[ msg.text ]]</span>
                </li>
            </ul>
        </div>
    </div>

    <script type="module">
        import { createApp } from '/{{channel}}/vue.js';
        import ColorHash from '/{{channel}}/color-hash.js';
        import { getEmoteAsUrl, parseEmotesInMessage } from '/{{channel}}/tmi-utils/index.js';

        async function fetch_(method, url, data) {
            const res = await fetch(url, {
                method: method,
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data),
            });
            if (res.status === 403) {
                alert('access denied, please copy your work and refresh the page');
            } else if (res.status !== 200) {
                alert(`unknown error ${res.status} "${await res.text()}" when calling ${url}`);
            }
            return res;
        }

        async function fetch_post(url, data) {
            return await fetch_('POST', url, data);
        }
        async function fetch_delete(url, data) {
            return await fetch_('DELETE', url, data);
        }

        createApp({
            delimiters: ['[[', ']]'],
            data() {
                return {
                    color_hash: new ColorHash({ lightness: [0.5, 0.6, 0.7, 0.8], saturation: [0.6, 0.7, 0.8, 0.9, 1] }),
                    user_colors: {},
                    channel: '{{channel}}',
                    channels: '{{channels}}'.split(','),
                    accessToken: '{{user.accessToken}}',
                    refreshToken: '{{user.refreshToken}}',
                    display_name: '{{user.display_name}}',
                    login: '{{user.login}}',
                    loggedIn: '{{user.login}}' !== '',
                    profile_image_url: '{{user.profile_image_url}}',
                    is_super_admin: '{{is_super_admin}}' === 'true',
                    is_chat_fullscreen: '{{is_chat_fullscreen}}' === 'true',
                    bgcolor: '{{bgcolor}}',
                    show_usernames: '{{show_usernames}}' !== 'false',
                    show_nicknames: '{{show_nicknames}}' !== 'false',
                    show_pronouns: '{{show_pronouns}}' !== 'false',
                    enabled_cooldown: '{{enabled_cooldown}}',
                    enabled_grayed_out: false,
                    chat: [],
                    viewers: {},
                    channel_props: {
                        enabled: undefined,
                        fwd_cmds_yt_twitch: undefined,
                        max_nickname_length: undefined,
                        greetz_threshold: undefined,
                        greetz_wb_threshold: undefined,
                        youtube_id: undefined,
                        owncast_url: undefined,
                        kick_username: undefined,
                        kick_chatroom_id: undefined,
                    },
                    channel_props_edit: {},
                    editing_username: undefined,
                    editing_nickname: '',
                    new_nickname: '',
                    new_username: '',
                    youtube_input: '',
                    owncast_input: '',
                    kick_input: '',
                    editing_fwd_idx: undefined,
                    editing_fwd_item: undefined,
                    new_cmd: '',
                }
            },
            methods: {
                compute_color(text) {
                    return this.color_hash.hex(text);
                },
                get_user_color(username) {
                    return this.user_colors[username] ?? this.compute_color(username);
                },
                myGetEmoteAsUrl(id) {
                    if (id.startsWith('https://')) {
                        return id;
                    }
                    return getEmoteAsUrl(id);
                },
                myParseEmotesInMessage(emotes, text) {
                    return parseEmotesInMessage(emotes, text);
                },
                websocket_connect() {
                    const ws = new WebSocket(`ws://${window.document.location.host}/{{channel}}`);
                    ws.binaryType = "blob";
                    // Log socket opening and closing
                    ws.addEventListener("open", event => {
                        console.log("Websocket connection opened");
                        ws.send('hello from client');
                    });
                    ws.addEventListener("close", event => {
                        console.log("Websocket connection closed");
                        setTimeout(this.websocket_connect, 5000);
                    });
                    ws.onmessage = this.websocket_message;
                },
                websocket_message(message) {
                    const data = JSON.parse(message.data);
                    console.log('websocket_message:', data);
                    const m = data.content;
                    if (data.type === 'chat') {
                        this.websocket_chat(m);
                    } else if (data.type === 'command') {
                        this.websocket_command(m);
                    } else if (data.type === 'channel_prop') {
                        console.log('channel_prop: ', m);
                        this.channel_props[m.prop_name] = m.prop_value;
                    } else if (data.type === 'viewer_prop') {
                        console.log('viewer_prop:', m);
                        if (this.viewers[m.username] === undefined) {
                            this.viewers[m.username] = {};
                        }
                        this.viewers[m.username][m.prop_name] = m.prop_value;
                    } else if (data.type === 'delete_viewer') { //might need to generalize this
                        delete this.viewers[m.username];
                    } else if (data.type === 'pronouns') {
                        this.chat.map(msg => {
                            if (msg.username === m.username && msg.pronouns === undefined) {
                                msg.pronouns = m.pronouns;
                            }
                            return msg;
                        });
                    } else {
                        console.log('unknown message:', data);
                    }
                },
                websocket_command(msg) {
                    if (msg.command === 'clear') {
                        this.chat = [];
                    }
                },
                websocket_chat(msg) {
                    if (msg.color) {
                        this.user_colors[msg.username] = msg.color;
                    }
                    this.chat.push(msg);
                    this.scroll_chat();
                },
                scroll_chat() {
                    const messages = document.querySelector('#messages');
                    this.$nextTick(() => {
                        messages.scrollTo(0, messages.scrollHeight);
                    });
                },
                async set_viewer_prop(username, prop_name, prop_value) {
                    return await fetch_post(`/{{channel}}/viewers/${username}/${prop_name}`, { prop_value: prop_value });
                },
                async set_channel_prop(prop_name, prop_value) {
                    return await fetch_post(`/{{channel}}/channel_props/${prop_name}`, { prop_value: prop_value });
                },
                async save_channel_prop(prop_name) {
                    return await this.set_channel_prop(prop_name, this.channel_props_edit[prop_name]);
                },
                get_channel_prop(prop_name) {
                    fetch(`{{channel}}/channel_props/${prop_name}`)
                        .then(res => res.json())
                        .then(json => {
                            console.log(prop_name, json);
                            this.channel_props[prop_name] = json;
                            this.channel_props_edit[prop_name] = json;
                        });
                },
                async set_enabled(enabled) {
                    this.enabled_grayed_out = true;
                    setTimeout(() => { this.enabled_grayed_out = false; }, this.enabled_cooldown);
                    const res = await fetch_post('/{{channel}}/channel_props/enabled', { prop_value: enabled });
                    if (await res.text() === 'wait') {
                        alert('please wait 5 seconds and try again');
                    }
                },
                set_custom_greetz(username) {
                    let new_greetz = prompt(`custom greetz for ${username}
put # where the nickname goes, for example "hola, #"
leave blank to revert to default greetz`, this.viewers[username].custom_greetz);
                    if (!new_greetz) {
                        new_greetz = undefined;
                    }
                    this.set_viewer_prop(username, 'custom_greetz', new_greetz);
                },
                save_nickname() {
                    this.set_viewer_prop(this.editing_username, 'nickname', this.editing_nickname);
                    this.editing_username = undefined;
                },
                add_nickname() {
                    this.set_viewer_prop(this.new_username, 'nickname', this.new_nickname);
                    this.new_username = '';
                    this.new_nickname = '';
                },
                delete_viewer(username) {
                    fetch_delete(`/${this.channel}/viewers/${username}`);
                },
                custom_channel() {
                    this.channel = prompt('enter channel name').toLowerCase();
                },
                find_youtube_id() {
                    this.youtube_id = '';
                    console.log(this.youtube_input);
                    // https://www.youtube.com/channel/UCmrLaVZneWG3kJyPqp-RFJQ
                    const regex = /(UC[-_a-zA-Z0-9]{22})/;
                    const match = regex.exec(this.youtube_input);
                    if (match) {
                        this.set_channel_prop('youtube_id', match[1]);
                    } else {
                        fetch('/{{channel}}/find_youtube_id?channel=' + encodeURIComponent(this.youtube_input))
                            .then(res => res.text())
                            .then(text => {
                                if (text === 'invalid') {
                                    this.get_channel_prop('youtube_id');
                                    alert('Invalid channel handle, URL, or ID');
                                } else if (text === 'error') {
                                    this.get_channel_prop('youtube_id');
                                    alert('Error finding channel ID. If this is broken, look online for how to find your channel ID and enter it here directly');
                                } else {
                                    this.set_channel_prop('youtube_id', text);
                                }
                            });
                    }
                },
                get_owncast_url() {
                    fetch('/owncast_url?channel=' + encodeURIComponent(this.channel))
                        .then(res => res.text())
                        .then(json => this.owncast_url = json);
                },
                async set_owncast_url(url) {
                    if (url.startsWith('http://')) {
                        url = url.replace('http://', '');
                    }
                    if (url.startsWith('https://')) {
                        url = url.replace('https://', '');
                    }
                    if (url.endsWith('/')) {
                        url = url.substr(0, url.length - 1);
                    }
                    this.set_channel_prop('owncast_url', url);
                },
                sanatize_kick_username(kick_username) {
                    if (kick_username.startsWith('http://')) {
                        kick_username = kick_username.replace('http://', '');
                    }
                    if (kick_username.startsWith('https://')) {
                        kick_username = kick_username.replace('https://', '');
                    }
                    if (kick_username.startsWith('kick.com/')) {
                        kick_username = kick_username.replace('kick.com/', '');
                    }
                    return kick_username;
                },
                async convert_kick_username_to_chatroom_id(kick_username) {
                    const res = await fetch('https://kick.com/api/v2/channels/' + kick_username);
                    return '' + (await res.json()).chatroom.id;
                },
                async kick_connect() {
                    const kick_username = this.sanatize_kick_username(this.kick_input);
                    this.set_channel_prop('kick_username', kick_username);
                    this.set_channel_prop('kick_chatroom_id', await this.convert_kick_username_to_chatroom_id(kick_username));
                },
                kick_disconnect() {
                    this.set_channel_prop('kick_username', undefined);
                    this.set_channel_prop('kick_chatroom_id', undefined);
                },
                check_youtube_status() {
                    fetch('/{{channel}}/status/youtube')
                        .then(res => res.json())
                        .then(json => {
                            console.log('/status/youtube', json);
                            alert(`YouTube Status:
channelId: ${json.listener?.channelId}
channelName: ${json.listener?.channelName}
videoId: ${json.listener?.videoId}
title: ${json.listener?.title}
isLive: ${json.listener?.isLive}`);
                        });
                },
                check_owncast_status() {
                    fetch('/{{channel}}/status/owncast')
                        .then(res => res.json())
                        .then(json => {
                            console.log('/status/owncast', json);
                            alert(`Owncast Status:
socket.servername: ${json.listener?.socket?.servername}
config.webSocketVersion: ${json.listener?.config?.webSocketVersion}`);
                        });
                },
                check_kick_status() {
                    fetch('/{{channel}}/status/kick')
                        .then(res => res.text())
                        .then(text => {
                            console.log('/status/kick', text);
                            alert(`Kick Status:
${text}`);
                        });
                },
                check_emotes_status() {
                    fetch('/{{channel}}/status/emotes')
                        .then(res => res.json())
                        .then(json => {
                            console.log('/status/emotes', json);
                            alert(`Emotes Status:
${JSON.stringify(json, undefined, 2)}`);
                        });
                },
                clear_chat() {
                    fetch_post('/{{channel}}/clear_chat');
                },
            },
            mounted() {
                this.websocket_connect();
                fetch('/{{channel}}/viewers')
                    .then(res => res.json())
                    .then(json => this.viewers = json);
                fetch('/{{channel}}/chat_history')
                    .then(res => res.json())
                    .then(json => {
                        json.forEach(msg => this.websocket_chat(msg));
                    });

                for (const prop_name of Object.keys(this.channel_props)) {
                    this.get_channel_prop(prop_name);
                }
            },
            watch: {
                channel(new_channel, old_channel) {
                    console.log(old_channel, new_channel);
                    window.location = '/' + new_channel;
                },
            },
            // computed: {
            //     dropdown_channels() {
            //         return [];
            //     }
            // }
        }).mount('#app');
    </script>
</body>

</html>