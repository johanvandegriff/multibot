<!doctype html>
<html>

<head>
    <title>{{ channel }} - chat</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="/static/style.css">
</head>

<body :style="{ 'background-color': [[ bgcolor ]] }">
    <div id="app">
        <div id="chat_fullscreen">
            <ul id="messages" :style="{ 'background-color': [[ bgcolor ]], 'height': '100vh', 'overflow': 'hidden' }">
                <li v-for="msg in chat">
                    <!-- TODO: get the correct username color from youtube -->
                    <span :style="{ color: msg.color || compute_color(msg.username), 'font-weight': 'bold' }">[[
                        msg.username
                        ]]</span>
                    <span>: </span>
                    <span v-if="msg.emotes">
                        <span v-for="{ type, value, raw } in this.parseEmotesInMessage(msg.emotes, msg.text)">
                            <span v-if="type === 'emote'">
                                <img style="margin: -.25rem 0; height: 1.2rem;" :src="getEmoteAsUrl(value)" :alt="raw" :title="raw" />
                            </span>
                            <span v-else>[[ value ]]</span>
                        </span>
                    </span>
                    <span v-else>[[ msg.text ]]</span>
                </li>
            </ul>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="/vue.js"></script>
    <script src="/color-hash.js"></script>


    <script type="module">
        import { getEmoteAsUrl, parseEmotesInMessage } from '/tmi-utils/index.js';

        const { createApp, ref } = Vue

        createApp({
            delimiters: ['[[', ']]'],
            data() {
                return {
                    colorHash: new ColorHash({ lightness: [0.5, 0.6, 0.7, 0.8], saturation: [0.6, 0.7, 0.8, 0.9, 1] }),
                    socket: undefined,
                    channel: '{{ channel }}',
                    bgcolor: '{{ bgcolor }}',
                    chat: [],
                    parseEmotesInMessage: parseEmotesInMessage,
                    getEmoteAsUrl: getEmoteAsUrl,
                }
            },
            methods: {
                compute_color(text) {
                    return this.colorHash.hex(text + "....");
                },
                scroll_chat() {
                    const messages = document.querySelector('#messages');
                    this.$nextTick(() => {
                        messages.scrollTo(0, messages.scrollHeight);
                    });
                },
                socket_connect() {
                    console.log('socket connected');
                    this.socket.emit('init', { 'channel': this.channel });
                },
                socket_error() {
                    console.error('socket error');
                },
                socket_chat(msg) {
                    console.log('chat: ', msg);
                    if (msg.clear_chat) {
                        console.log('clear_chat', msg.clear_chat);
                        this.chat = [];
                    } else {
                        this.chat.push(msg);
                        this.scroll_chat();
                    }
                },
            },
            mounted() {
                this.socket = io();
                this.socket.on('connect', this.socket_connect);
                this.socket.on('connect_failed', this.socket_error);
                this.socket.on('disconnect', this.socket_error);

                console.log('LISTENING ON:', this.channel + '/chat');
                this.socket.on(this.channel + '/chat', this.socket_chat);

                fetch('/chat_history?channel=' + encodeURIComponent(this.channel))
                    .then(res => res.json())
                    .then(json => {
                        this.chat = json;
                        this.scroll_chat();
                    });
            },
        }).mount('#app')
    </script>
</body>

</html>