<!doctype html>
<html>

<head>
    <title>JJ's Cool Bot</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="/static/style.css">
</head>

<body>
    <div id="app">
        <div id="login">
            <span v-if="loggedIn">
                <img :src="profile_image_url" />
                <div style="float: right">
                    <span v-if="is_super_admin" id="super_admin">SUPER ADMIN</span>
                    &nbsp;
                    <a :href="'/logout?returnTo=' + encodeURIComponent('#' + channel)">log out</a>
                    &nbsp;
                </div>
            </span>
            <span v-else>
                &nbsp;
                for streamers:
                <a href="/auth/twitch">log in</a>
                &nbsp;
            </span>
        </div>
        <div id="left_container">
            <h1>JJ's Cool Bot</h1>
            <p v-if="channels">
                Channel:

                <select v-model="channel">
                    <option selected :value="channel">[[ channel ]]</option>
                    <option v-if="loggedIn && channel !== login && !channels.includes(login)" :value="login">[[ login ]]
                    </option>
                    <option v-if="is_super_admin" v-for="c in all_channels.filter(c => c !== channel)" :value="c">[[ c
                        ]]</option>
                    <option v-else v-for="c in channels.filter(c => c !== channel)" :value="c">[[ c ]]</option>
                </select>
                <button @click="custom_channel">custom</button>
            </p>
            <p v-else>
                Loading...
            </p>
            <span v-if="loggedIn && channels">
                <span v-if="channel === login || is_super_admin">
                    <p v-if="channels.includes(channel)" style="background-color: #292; padding: 5px">
                        The bot is enabled on <span v-if="channel === login">your</span><span v-else>this</span> channel
                        ([[ channel ]]). <button style="color: #d22; font-weight: bold"
                            @click="set_enabled(false)">DISABLE</button>
                    </p>
                    <p v-else style="background-color: #d22; padding: 5px">
                        The bot is NOT enabled on <span v-if="channel === login">your</span><span v-else>this</span>
                        channel ([[ channel ]]). <button style="color: #d22; font-weight: bold"
                            @click="set_enabled(true)">ENABLE</button>
                    </p>
                    enter youtube channel URL or ID: <input type="text" v-model="youtube_input" />
                    <button @click="find_youtube_id">find channel</button>
                    <span v-if="youtube_id && youtube_id.length > 0">(youtube channel connected: <a
                            :href="'https://www.youtube.com/channel/' + youtube_id">[[ youtube_id ]]</a>)
                        <button @click="set_youtube_id('')">disconnect</button>
                    </span>
                    <span v-else>(no youtube channel connected)</span>
                    <button @click="check_youtube_status">check youtube chat status</button>

                    <p>
                    <h2>Forward Commands from Youtube to Twitch</h2>
                    <ul>
                        <li v-for="cmd, i in fwd_cmds_yt_twitch"><input type="text" v-model="cmd" />
                            <button @click="fwd_cmds_yt_twitch.splice(i, 1); send_cmds();">&nbsp; x &nbsp;</button>
                        </li>
                        <li><button @click="send_cmds">save</button></li>
                        <li><button @click="fwd_cmds_yt_twitch.push(new_cmd); new_cmd = ''; send_cmds();">add
                                new:</button><input type="text" v-model="new_cmd" /></li>
                    </ul>
                    </p>
                </span>
                <span v-else>
                    <p style="background-color: #555; padding: 5px">
                        logged in as
                        <a :href="'#' + login">[[ login ]]</a>,
                        viewing <span style="font-weight: bold;">[[ channel ]]</span>
                    </p>
                </span>
            </span>
        </div>

        <div id="chat">
            <div id="chat-header">
                <h2>Chat</h2>
                <a style="top: 0; position: absolute; left: 100px" target="_blank"
                    :href="'/chat?channel=' + channel">pop-out<img style="width:20px"
                        src="/static/external-link-ltr-icon.svg" alt="popout chat" /></a>
            </div>
            <ul id="messages">
                <li v-for="msg in chat">
                    <!-- TODO: get the correct username color from youtube -->
                    <span :style="{ color: msg.color || compute_color(msg.username), 'font-weight': 'bold' }">[[
                        msg.username ]]</span>
                    <span>: </span>
                    <span v-if="msg.emotes">
                        <span v-for="{ type, value, raw } in this.parseEmotesInMessage(msg.emotes, msg.text)">
                            <span v-if="type === 'emote'">
                                <img style="margin: -.25rem 0; height: 1.2rem;" :src="getEmoteAsUrl(value)" :alt="raw"
                                    :title="raw" />
                            </span>
                            <span v-else>[[ value ]]</span>
                        </span>
                    </span>
                    <span v-else>[[ msg.text ]]</span>
                </li>
            </ul>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script src="/vue.js"></script>
    <script src="/color-hash.js"></script>

    <script type="module">
        import { getEmoteAsUrl, parseEmotesInMessage } from '/tmi-utils/index.js';
        async function fetch_post(url, data) {
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data),
            });
            if (res.status === 403) {
                alert('access denied, please copy your work and refresh the page');
            } else if (res.status !== 200) {
                alert(`unknown error ${res.status} "${await res.text()}" when calling ${url}`);
            }
            return res;
        }

        const { createApp, ref } = Vue

        createApp({
            delimiters: ['[[', ']]'],
            data() {
                return {
                    colorHash: new ColorHash({ lightness: [0.5, 0.6, 0.7, 0.8], saturation: [0.6, 0.7, 0.8, 0.9, 1] }),
                    socket: undefined,
                    channel: undefined,
                    channels: undefined,
                    chat: [],
                    accessToken: '{{accessToken}}',
                    refreshToken: '{{refreshToken}}',
                    display_name: '{{display_name}}',
                    login: '{{login}}',
                    loggedIn: '{{login}}' !== '',
                    profile_image_url: '{{profile_image_url}}',
                    is_super_admin: '{{is_super_admin}}' === 'true',
                    youtube_input: '',
                    youtube_id: '',
                    fwd_cmds_yt_twitch: [],
                    new_cmd: '',
                    parseEmotesInMessage: parseEmotesInMessage,
                    getEmoteAsUrl: getEmoteAsUrl,
                }
            },
            methods: {
                compute_color(text) {
                    return this.colorHash.hex(text + "....");
                },
                scroll_chat() {
                    const messages = document.querySelector('#messages');
                    this.$nextTick(() => {
                        messages.scrollTo(0, messages.scrollHeight);
                    });
                },
                socket_connect() {
                    console.log('socket connected');
                    this.socket.emit('init', { 'channel': this.channel });
                },
                socket_error() {
                    console.error('socket error');
                },
                socket_chat(msg) {
                    console.log('chat: ', msg);
                    if (msg.clear_chat) {
                        console.log('clear_chat', msg.clear_chat);
                        this.chat = [];
                    } else {
                        this.chat.push(msg);
                        this.scroll_chat();
                    }
                },
                socket_event(msg) {
                    console.log('event: ', msg);
                    if (msg.channel && msg.enabled !== undefined) {
                        console.log(msg.channel, msg.enabled, this.channels);
                        this.get_channels(); //TODO just adjust what changed instead of getting everything
                    }
                    if (msg.channel && msg.fwd_cmds_yt_twitch !== undefined) {
                        console.log(msg.channel, msg.fwd_cmds_yt_twitch);
                        this.fwd_cmds_yt_twitch = msg.fwd_cmds_yt_twitch;
                    }
                },
                load_from_local_url() {
                    this.channel = window.location.href.split('#')[1]?.toLowerCase();
                    if (this.channel) {
                        window.location = '#' + this.channel;
                    }
                },
                get_channels() {
                    fetch('/channels')
                        .then(res => res.json())
                        .then(json => {
                            this.all_channels = json.all_channels;
                            this.channels = json.channels;
                        });
                },
                async set_enabled(enabled) {
                    const res = await fetch_post('/enabled', { channel: this.channel, enabled: enabled, });
                    if (await res.text() === 'wait') {
                        alert('please wait 5 seconds and try again');
                    }
                },
                custom_channel() {
                    this.channel = prompt('enter channel name').toLowerCase();
                },
                get_youtube_id() {
                    fetch('/youtube_id?channel=' + encodeURIComponent(this.channel))
                        .then(res => res.text())
                        .then(text => this.youtube_id = text);
                },
                find_youtube_id() {
                    this.youtube_id = '';
                    console.log(this.youtube_input);
                    // https://www.youtube.com/channel/UCmrLaVZneWG3kJyPqp-RFJQ
                    const regex = /(UC[-_a-zA-Z0-9]{22})/;
                    const match = regex.exec(this.youtube_input);
                    if (match) {
                        this.set_youtube_id(match[1]);
                    } else {
                        fetch('/find_youtube_id?channel=' + encodeURIComponent(this.youtube_input))
                            .then(res => res.text())
                            .then(text => {
                                if (text === 'invalid') {
                                    this.get_youtube_id();
                                    alert('Invalid channel handle, URL, or ID');
                                } else if (text === 'error') {
                                    this.get_youtube_id();
                                    alert('Error finding channel ID. If this is broken, look online for how to find your channel ID and enter it here directly');
                                } else {
                                    this.set_youtube_id(text);
                                }
                            });
                    }
                },
                async set_youtube_id(id) {
                    const res = await fetch_post('/youtube_id', { channel: this.channel, youtube_id: id });
                    if (res.status === 200) {
                        this.youtube_id = id;
                    }
                },
                send_cmds() {
                    fetch_post('/fwd_cmds_yt_twitch', { channel: this.channel, fwd_cmds_yt_twitch: this.fwd_cmds_yt_twitch });
                },
                check_youtube_status() {
                    fetch('/youtube_status?channel=' + this.channel)
                        .then(res => res.json())
                        .then(json => {
                            console.log('youtube_status', json);
                            alert(`YouTube Status:
youtube_id: ${json.youtube_id}
channelId: ${json.listener?.channelId}
channelName: ${json.listener?.channelName}
videoId: ${json.listener?.videoId}
title: ${json.listener?.title}
isLive: ${json.listener?.isLive}`);
                        });
                },
            },
            mounted() {
                this.get_channels();
                this.load_from_local_url();
                //whenever the user goes forward/back in history, re-read from the local url
                addEventListener('popstate', event => {
                    this.load_from_local_url();
                });
                if (!this.channel && this.loggedIn) {
                    window.location = '#' + this.display_name.toLowerCase();
                }
            },
            watch: {
                channel(new_channel, old_channel) {
                    window.location = '#' + new_channel;
                    if (this.socket) {
                        this.socket.disconnect();
                    }
                    this.chat = []

                    if (this.channel) {
                        this.get_youtube_id();
                        this.socket = io();

                        this.socket.on('connect', this.socket_connect);
                        this.socket.on('connect_failed', this.socket_error);
                        this.socket.on('disconnect', this.socket_error);

                        console.log('LISTENING ON:', new_channel + '/chat', 'events');
                        this.socket.on(new_channel + '/chat', this.socket_chat);
                        this.socket.on('events', this.socket_event);

                        fetch('/chat_history?channel=' + encodeURIComponent(this.channel))
                            .then(res => res.json())
                            .then(json => {
                                this.chat = json;
                                this.scroll_chat();
                            });
                        fetch('/fwd_cmds_yt_twitch?channel=' + encodeURIComponent(this.channel))
                            .then(res => res.json())
                            .then(json => this.fwd_cmds_yt_twitch = json);
                    }
                },
            },
            // computed: {
            //     dropdown_channels() {
            //         return [];
            //     }
            // }
        }).mount('#app')
    </script>
</body>

</html>