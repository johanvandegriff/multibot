<!doctype html>
<html>

<head>
    <title>JJBotBot</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/api/fonts/cabin/400.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            /* box-sizing: border-box; */
        }

        :root {
            --mono-font: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace;
        }

        /*temp border*/
        /* div {
            border: 1px red;
            border-style: dashed;
        } */

        html {
            height: 100%;
        }

        body {
            height: 100%;
            line-height: 1.6;
            font-size: 18px;
            background-color: #202020;
            color: white;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            line-height: 1.2;
        }

        #app {
            margin: 0px 10px;
        }

        #login {
            position: fixed;
            top: 0;
            right: 0;
            z-index: 1;
            border: 1px solid white;
            /* padding: 2px 0px 0px 2px; */
            margin: 0px 1px;
            height: 30px;
            background: #282828;
        }

        #login img {
            height: 30px;
        }

        #super_admin {
            border: 1px solid red;
            border-radius: 5px;
            background-color: #611;
            padding: 4px;
            font-family: var(--mono-font);
            font-weight: bold;
        }

        #left_container {
            width: 50%;
        }

        #nicknames {
            list-style-type: none;
            font-weight: bold;
            padding: 10px;
        }

        #nicknames_container {
            width: 50%;
        }

        .edit {
            font-size: larger;
            color: white;
        }

        .delete {
            color: white;
        }

        .nickname {
            font-family: var(--mono-font);
            font-weight: bold;
            /* font-size: smaller; */
        }

        .equals {
            color: white
        }

        .pronoun {
            padding: 0.5px;
            margin-right: 4px;
            font-weight: bold;
            border-radius: 5px;
            font-size: smaller;
            border: 1px solid lightgray;
        }

        #chat {
            width: 50%;
            height: 100%;
            float: right;
            right: 0;
            top: 0;
            position: fixed;
            background: #101010;
        }

        #chat-header {
            height: 125px;
            padding: 0px 10px;
        }

        #messages {
            list-style-type: none;
            margin: 0;
            padding: 2px 0;
            height: 100%;
            height: calc(100vh - 125px - 4px);
            overflow-y: scroll;
            word-wrap: break-word;
            background: #101010;
        }

        #messages li {
            padding: 2px 10px;
        }

        /* #messages li:nth-child(odd) {
            background: #eee;
        } */

        a:link {
            color: #36c;
        }

        a:visited {
            color: #94f;
        }

        .right {
            float: right;
        }

        .nowrap {
            white-space: nowrap;
        }

        .alert {
            padding: 5px;
            margin-right: 10px;
        }

        .red-bg {
            color: white;
            background-color: #d22;
        }

        .green-bg {
            color: white;
            background-color: #292;
        }

        .gray-bg {
            color: white;
            background-color: #444;
        }

        .red {
            color: #d22;
            background-color: white;
        }

        .green {
            color: #292;
            background-color: white;
        }

        .bold {
            font-weight: bold;
        }

        .rounded {
            padding: 2px;
            border-radius: 8px;
        }

        .emote {
            margin: -.75rem 0;
            height: 2.2rem;
        }

        .button {
            font-weight: bold;
            border: 1px solid white;
            border-radius: 8px;
            padding: 2px;
            background-color: #282828;
            text-decoration: none;
        }

        button:disabled,
        button[disabled] {
            background-color: #aaa;
            color: #555;
        }
    </style>
</head>

<body id="app">
    <div id="container" :style="{ 'font-family': channel_props.font }">
        <div id="login" v-if="!is_chat_fullscreen">
            <span v-if="is_logged_in">
                <a v-if="login !== channel && is_onboarded" :href="'/' + login"><img :src="profile_image_url" /></a>
                <img v-else :src="profile_image_url" />
                <div class="right">
                    &nbsp;
                    <a v-if="login !== channel && is_onboarded" :href="'/' + login">[[display_name]]</a>
                    <span v-else>[[display_name]]</span>
                    <span v-if="is_super_admin">&nbsp;<span id="super_admin">SUPER ADMIN</span></span>
                    &nbsp;
                    <a href="/api/logout?returnTo={{channel}}">log out</a>
                    &nbsp;
                </div>
            </span>
            <span v-else>
                &nbsp;
                for streamers:
                <a href="/api/auth/twitch">log in</a>
                &nbsp;
            </span>
        </div>
        <div id="left_container" v-if="!is_chat_fullscreen">
            <a href="/">
                <h1>JJBotBot</h1>
            </a>
            <p v-if="channels">
                Channel:
                <select v-model="channel">
                    <option selected :value="channel">[[ channel ]]</option>
                    <option v-if="is_logged_in && is_onboarded && channel !== login" :value="login">[[ login
                        ]]
                    </option>
                    <option v-for="c in channels.filter(c => c !== channel && c !== login)" :value="c">[[ c ]]</option>
                </select>
            </p>
            <p v-else>
                Loading...
            </p>
            <span v-if="is_logged_in && channels">
                <span v-if="channel === login || is_super_admin">
                    <p v-if="channel_props.enabled" class="alert green-bg">
                        The bot is enabled on <span v-if="channel === login">your</span><span v-else>this</span> channel
                        ([[ channel ]]). <button class="red bold rounded" :disabled="enabled_grayed_out"
                            @click="set_enabled(false)">DISABLE</button>
                    </p>
                    <p v-else class="alert red-bg">The bot is NOT enabled on <span
                            v-if="channel === login">your</span><span v-else>this</span> channel ([[ channel ]]).
                        <button class="red bold rounded" :disabled="enabled_grayed_out"
                            @click="set_enabled(true)">ENABLE</button>
                    </p>

                    <p>
                        twitch channel connected: <a :href="'https://twitch.tv/' + channel">[[channel]]</a>
                        <button @click="check_twitch_status">check twitch chat status</button>
                    </p>
                    <p>
                        <span v-if="channel_props.youtube_id && channel_props.youtube_id.length > 0">
                            youtube channel connected:
                            <a :href="'https://www.youtube.com/channel/' + channel_props.youtube_id">
                                [[channel_props.youtube_id ]]
                            </a>
                            <button @click="set_channel_prop('youtube_id', undefined)">disconnect</button>
                        </span>
                        <span v-else>
                            no youtube channel connected - enter youtube channel URL or ID:
                            <input type="text" v-model="youtube_input" />
                            <button @click="find_youtube_id">find channel</button>
                        </span>
                        <button @click="check_youtube_status">check youtube chat status</button>
                    </p>
                    <p>
                        <span v-if="channel_props.owncast_url && channel_props.owncast_url.length > 0">
                            owncast connected:
                            <a :href="'https://' + channel_props.owncast_url">[[ channel_props.owncast_url ]]</a>
                            <button @click="set_channel_prop('owncast_url', undefined)">disconnect</button>
                        </span>
                        <span v-else>
                            owncast not connected - enter owncast URL:
                            <input type="text" v-model="owncast_input" />
                            <button @click="set_owncast_url(owncast_input)">connect</button>
                        </span>
                        <button @click="check_owncast_status">check owncast chat status</button>
                    </p>
                    <p>
                        <span v-if="channel_props.kick_chatroom_id && channel_props.kick_chatroom_id.length > 0">kick
                            connected:
                            <a :href="'https://kick.com/' + channel_props.kick_username">[[ channel_props.kick_username
                                ]] ([[ channel_props.kick_chatroom_id
                                ]])</a>
                            <button @click="kick_disconnect">disconnect</button>
                        </span>
                        <span v-else>
                            kick not connected - enter kick username: <input type="text" v-model="kick_input" />
                            <button @click="kick_connect">connect</button>
                        </span>
                        <button @click="check_kick_status">check kick chat status</button>
                    </p>
                    <p>
                        <button @click="check_emotes_status">check 3rd party emotes status</button>
                        <button @click="clear_chat">clear chat</button>
                    </p>
                    <h2>Forward Commands from Youtube to Twitch</h2>
                    <ul>
                        <li v-for="cmd, i in channel_props_edit.fwd_cmds_yt_twitch">
                            <span v-if="editing_fwd_idx === i">
                                <input type="text" v-model="editing_fwd_item" />
                                <button
                                    @click="channel_props_edit.fwd_cmds_yt_twitch[i] = editing_fwd_item; editing_fwd_idx = undefined; save_channel_prop('fwd_cmds_yt_twitch')">done</button>
                            </span>
                            <span v-else class="edit" v-if="is_auth"
                                @click="editing_fwd_idx = i; editing_fwd_item = cmd">✎ [[cmd]]
                            </span>
                            <span class="delete"
                                @click="channel_props_edit.fwd_cmds_yt_twitch.splice(i, 1); save_channel_prop('fwd_cmds_yt_twitch')">
                                ⓧ</span>
                        </li>
                        <li><button
                                @click="channel_props_edit.fwd_cmds_yt_twitch.push(new_cmd); new_cmd = ''; save_channel_prop('fwd_cmds_yt_twitch')">
                                add new:</button><input type="text" v-model="new_cmd" /></li>
                    </ul>
                </span>
                <span v-else>
                    <p class="alert gray-bg">
                        logged in as
                        <a v-if="is_onboarded" :href="'/' + login">[[ login ]]</a><span v-else>[[ login ]]</span>,
                        viewing <span class="bold">[[ channel ]]</span>
                    </p>
                </span>
            </span>
            <span v-if="channel && channels">
                <h2>Nickname Ledger</h2>
                <span v-if="channel === login || is_super_admin">
                    max nickname length: <input v-model="channel_props_edit.max_nickname_length" type="number"> <button
                        @click="save_channel_prop('max_nickname_length')"
                        v-if="channel_props_edit.max_nickname_length !== channel_props.max_nickname_length"
                        class="red-bg rounded">save</button><br />
                    greetz threshold: <input v-model="channel_props_edit.greetz_threshold" type="number"> <button
                        @click="save_channel_prop('greetz_threshold')"
                        v-if="channel_props_edit.greetz_threshold !== channel_props.greetz_threshold"
                        class="red-bg rounded">save</button><br />
                    greetz wb threshold: <input v-model="channel_props_edit.greetz_wb_threshold" type="number"> <button
                        @click="save_channel_prop('greetz_wb_threshold')"
                        v-if="channel_props_edit.greetz_wb_threshold !== channel_props.greetz_wb_threshold"
                        class="red-bg rounded">save</button><br />
                </span>
                <span v-if="channel_props.enabled">
                    <p v-if="channel === login || is_super_admin" class="alert gray-bg">
                        Use <code>!nick</code> in the chat to show up here!
                    </p>
                    <p v-else class="alert green-bg">
                        Use <code>!nick</code> in [[ channel ]]'s chat to show up here!
                    </p>
                </span>
                <p v-else-if="!(channel === login || is_super_admin)" class="alert red-bg">
                    The bot is NOT enabled on this channel ([[ channel ]]), ask the streamer to enable it by
                    visiting this page and logging in.
                </p>
                <ul id="nicknames">
                    <li v-for="username in Object.keys(viewers)" :style="{ color: get_user_color(username) }">
                        <span v-if="editing_username === username">
                            <input v-model="editing_nickname">
                            <button @click="save_nickname">done</button>
                        </span>
                        <span v-else>
                            <span class="edit" v-if="is_auth"
                                @click="editing_nickname = viewers[username].nickname; editing_username = username">✎
                            </span>
                            <span class="nickname">[[viewers[username].nickname]]</span>
                        </span>
                        <span class="equals"> = </span>
                        <span class="username">[[username]]</span>
                        <span class="delete" v-if="is_auth">
                            &nbsp;<button class="custom_greetz" @click="set_custom_greetz(username)">custom greetz
                                ([[ viewers[username].custom_greetz ?? 'none set' ]])</button>
                            <span class="delete" @click="delete_viewer(username)"> ⓧ</span>
                        </span>
                    </li>
                    <li v-if="is_auth">
                        <input v-model="new_nickname" style="width: 100px">
                        <span class="equals"> = </span>
                        <input v-model="new_username">
                        <button @click="add_nickname">&nbsp; + &nbsp;</button>
                        (case sensitive)
                    </li>
                </ul>
            </span>
            <span v-if="is_auth">
                <br /><br /><br /><br />
                <br /><br /><br /><br />
                <label><input type="checkbox" v-model="confirm_delete"> confirm</label> <button class="red bold rounded"
                    @click="offboard(channel)" :disabled="!confirm_delete">DELETE ACCOUNT</button>
            </span>
        </div>

        <div :id="is_chat_fullscreen ? 'chat_fullscreen' : 'chat'">
            <div id="chat-header" v-if="!is_chat_fullscreen">
                <br />
                <h2 style="display:inline">Chat</h2>
                &nbsp;
                <a class="button" target="_blank" href="/{{channel}}/chat">
                    &nbsp; pop-out
                    <svg style="width:20px" xmlns="http://www.w3.org/2000/svg" width="12" height="12">
                        <path fill="#fff" stroke="#36c" d="M1.5 4.518h5.982V10.5H1.5z" />
                        <path fill="#36c"
                            d="M5.765 1H11v5.39L9.427 7.937l-1.31-1.31L5.393 9.35l-2.69-2.688 2.81-2.808L4.2 2.544z" />
                        <path fill="#fff"
                            d="m9.995 2.004.022 4.885L8.2 5.07 5.32 7.95 4.09 6.723l2.882-2.88-1.85-1.852z" />
                    </svg>
                </a>
                <span v-if="is_auth">
                    &nbsp;
                    font:
                    <select v-model="channel_props_edit.font" @change="save_font">
                        <option v-if="!fonts.includes(channel_props_edit.font)" :value="channel_props_edit.font">[[
                            font_name(channel_props_edit.font) ]]</option>
                        <option v-for="f in fonts" :value="f">[[ font_name(f) ]]</option>
                    </select>
                    <span v-if="actual_font !== font_name(channel_props_edit.font)"> fallback: [[ actual_font ]]</span>

                    text shadow:
                    <select v-model="channel_props_edit.text_shadow" @change="save_text_shadow">
                        <option v-if="!text_shadows.includes(channel_props_edit.text_shadow)"
                            :value="channel_props_edit.text_shadow">[[
                            channel_props_edit.text_shadow ]]</option>
                        <option v-for="item in text_shadows" :value="item">[[ item ]]</option>
                    </select>
                    <br />
                    show:
                    <label class="nowrap"><input type="checkbox" v-model="channel_props_edit.show_usernames"
                            @change="this.save_channel_prop('show_usernames')">usernames</label>&nbsp;
                    <label class="nowrap"><input type="checkbox" v-model="channel_props_edit.show_nicknames"
                            @change="this.save_channel_prop('show_nicknames')">nicknames</label>&nbsp;
                    <label class="nowrap"><input type="checkbox" v-model="channel_props_edit.show_pronouns"
                            @change="this.save_channel_prop('show_pronouns')">pronouns</label>
                </span>
            </div>
            <ul id="messages" :style="Object.assign({},
                    { 'text-shadow': channel_props.text_shadow },
                    is_chat_fullscreen ? { 'background-color': [[ bgcolor ]], 'height': '100vh', 'overflow': 'hidden' } : {}
                )">
                <li v-for="msg in chat">
                    <!-- TODO: get the correct username color from youtube -->
                    <span class="bold" :style="{ color: get_user_color(msg.username) }">
                        <span v-if="channel_props.show_pronouns && msg.pronouns" class="pronoun"
                            :style="{ 'border-color': get_user_color(msg.username) }">
                            [[ msg.pronouns ]]
                        </span>
                        <span v-if="channel_props.show_usernames || !(channel_props.show_nicknames && msg.nickname)">
                            [[ msg.username ]]</span>
                        <span v-if="channel_props.show_nicknames && msg.nickname">
                            <span v-if="channel_props.show_usernames"> (<span class="nickname">
                                    [[msg.nickname]]</span>)</span>
                            <span v-else> <span class="nickname">[[msg.nickname]]</span></span>
                        </span>
                    </span>
                    <span>: </span>
                    <span v-if="msg.emotes">
                        <span v-for="{ type, value, raw } in myParseEmotesInMessage(msg.emotes, msg.text)">
                            <span v-if="type === 'emote'">
                                <img class="emote" :src="myGetEmoteAsUrl(value)" :alt="raw" :title="raw" />
                            </span>
                            <span v-else>[[ value ]]</span>
                        </span>
                    </span>
                    <span v-else>[[ msg.text ]]</span>
                </li>
            </ul>
        </div>
        <span id="font_test" style="position: absolute; visibility: hidden; white-space: nowrap;">
            `1234567890-=qwertyuiop[]\asdfghjkl;'zxcvbnm,./~!@#$%^&amp;*()_+QWERTYUIOP{}|ASDFGHJKL:&quot;ZXCVBNM&lt;&gt;?
        </span>
        <span style="font-family: Cabin;"></span><!-- needed to make sure the font is loaded locally -->
    </div>

    <script type="module">
        import { createApp } from '/{{channel}}/vue.js';
        import ColorHash from '/{{channel}}/color-hash.js';
        import { getEmoteAsUrl, parseEmotesInMessage } from '/{{channel}}/tmi-utils/index.js';

        async function fetch_(method, url, data) {
            const res = await fetch(url, {
                method: method,
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data),
            });
            if (res.status === 403) {
                alert('access denied, please copy your work and refresh the page');
            } else if (res.status !== 200) {
                alert(`unknown error ${res.status} "${await res.text()}" when calling ${url}`);
            }
            return res;
        }

        async function fetch_post(url, data) {
            return await fetch_('POST', url, data);
        }
        async function fetch_delete(url, data) {
            return await fetch_('DELETE', url, data);
        }

        createApp({
            delimiters: ['[[', ']]'],
            data() {
                return {
                    page_hash: '{{page_hash}}',
                    color_hash: new ColorHash({ lightness: [0.5, 0.6, 0.7, 0.8], saturation: [0.6, 0.7, 0.8, 0.9, 1] }),
                    user_colors: {},
                    channel: '{{channel}}',
                    channels: '{{channels}}'.split(','),
                    accessToken: '{{user.accessToken}}',
                    refreshToken: '{{user.refreshToken}}',
                    display_name: '{{user.display_name}}',
                    login: '{{user.login}}',
                    is_logged_in: '{{user.login}}' !== '',
                    profile_image_url: '{{user.profile_image_url}}',
                    is_super_admin: '{{is_super_admin}}' === 'true',
                    is_chat_fullscreen: '{{is_chat_fullscreen}}' === 'true',
                    bgcolor: '{{bgcolor}}',
                    enabled_cooldown: '{{enabled_cooldown}}',
                    enabled_grayed_out: false,
                    chat: [],
                    viewers: {},
                    channel_props: {
                        enabled: undefined,
                        fwd_cmds_yt_twitch: undefined,
                        max_nickname_length: undefined,
                        greetz_threshold: undefined,
                        greetz_wb_threshold: undefined,
                        youtube_id: undefined,
                        owncast_url: undefined,
                        kick_username: undefined,
                        kick_chatroom_id: undefined,
                        show_usernames: undefined,
                        show_nicknames: undefined,
                        show_pronouns: undefined,
                        text_shadow: undefined,
                        font: undefined,
                    },
                    channel_props_edit: {},
                    editing_username: undefined,
                    editing_nickname: '',
                    new_nickname: '',
                    new_username: '',
                    youtube_input: '',
                    owncast_input: '',
                    kick_input: '',
                    editing_fwd_idx: undefined,
                    editing_fwd_item: undefined,
                    new_cmd: '',
                    confirm_delete: false,
                    fonts: [
                        undefined,
                        `"Cabin", "Segoe UI", "Helvetica Neue", Helvetica, Arial, sans-serif`,
                        `Arial, sans-serif`,
                        `system-ui, sans-serif`,
                        `'Segoe Print', 'Bradley Hand', Chilanka, TSCu_Comic, casual, cursive`,
                        `Charter, 'Bitstream Charter', 'Sitka Text', Cambria, serif`,
                        `'Iowan Old Style', 'Palatino Linotype', 'URW Palladio L', P052, serif`,
                        `Seravek, 'Gill Sans Nova', Ubuntu, Calibri, 'DejaVu Sans', source-sans-pro, sans-serif`,
                        `Avenir, Montserrat, Corbel, 'URW Gothic', source-sans-pro, sans-serif`,
                        `Optima, Candara, 'Noto Sans', source-sans-pro, sans-serif`,
                        `Inter, Roboto, 'Helvetica Neue', 'Arial Nova', 'Nimbus Sans', Arial, sans-serif`,
                        `'Nimbus Mono PS', 'Courier New', monospace`,
                        `ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace`,
                        `Bahnschrift, 'DIN Alternate', 'Franklin Gothic Medium', 'Nimbus Sans Narrow', sans-serif-condensed, sans-serif`,
                        `ui-rounded, 'Hiragino Maru Gothic ProN', Quicksand, Comfortaa, Manjari, 'Arial Rounded MT', 'Arial Rounded MT Bold', Calibri, source-sans-pro, sans-serif`,
                        `Rockwell, 'Rockwell Nova', 'Roboto Slab', 'DejaVu Serif', 'Sitka Small', serif`,
                        `Superclarendon, 'Bookman Old Style', 'URW Bookman', 'URW Bookman L', 'Georgia Pro', Georgia, serif`,
                        `Didot, 'Bodoni MT', 'Noto Serif Display', 'URW Palladio L', P052, Sylfaen, serif`,
                        `Impact, Haettenschweiler, "Franklin Gothic Bold", Charcoal, "Helvetica Inserat", "Bitstream Vera Sans Bold", "Arial Black", sans-serif`,
                        `custom`,
                    ],
                    actual_font: undefined,
                    text_shadows: [
                        '',
                        '1px 1px 2px black',
                        '2px 2px 4px black',
                        '1px 1px 2px pink',
                        '1px 1px 2px red',
                        '2px 0 10px #FC0',
                        'custom',
                    ],
                }
            },
            methods: {
                compute_color(text) {
                    return this.color_hash.hex(text);
                },
                get_user_color(username) {
                    return this.user_colors[username] ?? this.compute_color(username);
                },
                myGetEmoteAsUrl(id) {
                    if (id.startsWith('https://')) {
                        return id;
                    }
                    return getEmoteAsUrl(id);
                },
                myParseEmotesInMessage(emotes, text) {
                    return parseEmotesInMessage(emotes, text);
                },
                websocket_connect() {
                    const ws_origin = window.document.location.origin.replace('http', 'ws');
                    const ws = new WebSocket(`${ws_origin}/{{channel}}`);
                    ws.binaryType = "blob";
                    // Log socket opening and closing
                    ws.addEventListener("open", event => {
                        console.log("Websocket connection opened");
                        ws.send('hello from client');
                    });
                    ws.addEventListener("close", event => {
                        console.log("Websocket connection closed");
                        setTimeout(this.websocket_connect, 500);
                    });
                    ws.onmessage = this.websocket_message;
                },
                websocket_message(message) {
                    const data = JSON.parse(message.data);
                    console.log('websocket_message:', data);
                    const m = data.content;
                    if (data.type === 'chat') {
                        this.websocket_chat(m);
                    } else if (data.type === 'command') {
                        this.websocket_command(m);
                    } else if (data.type === 'channel_prop') {
                        console.log('channel_prop: ', m);
                        this.channel_props[m.prop_name] = m.prop_value;
                    } else if (data.type === 'viewer_prop') {
                        console.log('viewer_prop:', m);
                        if (this.viewers[m.username] === undefined) {
                            this.viewers[m.username] = {};
                        }
                        this.viewers[m.username][m.prop_name] = m.prop_value;
                    } else if (data.type === 'delete_viewer') { //might need to generalize this
                        delete this.viewers[m.username];
                    } else if (data.type === 'pronouns') {
                        this.chat.map(msg => {
                            if (msg.username === m.username && msg.pronouns === undefined) {
                                msg.pronouns = m.pronouns;
                            }
                            return msg;
                        });
                    } else if (data.type === 'page_hash') {
                        if (this.page_hash !== m.page_hash) {
                            if (this.is_chat_fullscreen || !this.is_auth || confirm('new version available, reload the page? (if you have unsaved work, cancel this, save, and reload the page)')) {
                                window.location.reload();
                            }
                        }
                    } else {
                        console.log('unknown message:', data);
                    }
                },
                websocket_command(msg) {
                    if (msg.command === 'clear') {
                        this.chat = [];
                    }
                },
                websocket_chat(msg) {
                    if (msg.color) {
                        this.user_colors[msg.username] = msg.color;
                    }
                    this.chat.push(msg);
                    this.scroll_chat();
                },
                scroll_chat() {
                    const messages = document.querySelector('#messages');
                    this.$nextTick(() => {
                        messages.scrollTo(0, messages.scrollHeight);
                    });
                },
                async set_viewer_prop(username, prop_name, prop_value) {
                    return await fetch_post(`/{{channel}}/viewers/${username}/${prop_name}`, { prop_value: prop_value });
                },
                async set_channel_prop(prop_name, prop_value) {
                    return await fetch_post(`/{{channel}}/channel_props/${prop_name}`, { prop_value: prop_value });
                },
                async save_channel_prop(prop_name) {
                    return await this.set_channel_prop(prop_name, this.channel_props_edit[prop_name]);
                },
                get_channel_prop(prop_name) {
                    fetch(`/{{channel}}/channel_props/${prop_name}`)
                        .then(res => res.json())
                        .then(json => {
                            console.log(prop_name, json);
                            this.channel_props[prop_name] = json;
                            this.channel_props_edit[prop_name] = json;
                        });
                },
                async set_enabled(enabled) {
                    this.enabled_grayed_out = true;
                    setTimeout(() => { this.enabled_grayed_out = false; }, this.enabled_cooldown);
                    const res = await fetch_post('/{{channel}}/channel_props/enabled', { prop_value: enabled });
                    if (await res.text() === 'wait') {
                        alert('please wait 5 seconds and try again');
                    }
                },
                set_custom_greetz(username) {
                    let new_greetz = prompt(`custom greetz for ${username}
put # where the nickname goes, for example "hola, #"
leave blank to revert to default greetz`, this.viewers[username].custom_greetz);
                    if (!new_greetz) {
                        new_greetz = undefined;
                    }
                    this.set_viewer_prop(username, 'custom_greetz', new_greetz);
                },
                save_nickname() {
                    this.set_viewer_prop(this.editing_username, 'nickname', this.editing_nickname);
                    this.editing_username = undefined;
                },
                add_nickname() {
                    this.set_viewer_prop(this.new_username, 'nickname', this.new_nickname);
                    this.new_username = '';
                    this.new_nickname = '';
                },
                delete_viewer(username) {
                    fetch_delete(`/${this.channel}/viewers/${username}`);
                },
                find_youtube_id() {
                    this.youtube_id = '';
                    console.log(this.youtube_input);
                    // https://www.youtube.com/channel/UCmrLaVZneWG3kJyPqp-RFJQ
                    const regex = /(UC[-_a-zA-Z0-9]{22})/;
                    const match = regex.exec(this.youtube_input);
                    if (match) {
                        this.set_channel_prop('youtube_id', match[1]);
                    } else {
                        fetch('/{{channel}}/find_youtube_id?channel=' + encodeURIComponent(this.youtube_input))
                            .then(res => res.text())
                            .then(text => {
                                if (text === 'invalid') {
                                    this.get_channel_prop('youtube_id');
                                    alert('Invalid channel handle, URL, or ID');
                                } else if (text === 'error') {
                                    this.get_channel_prop('youtube_id');
                                    alert('Error finding channel ID. If this is broken, look online for how to find your channel ID and enter it here directly');
                                } else {
                                    this.set_channel_prop('youtube_id', text);
                                }
                            });
                    }
                },
                get_owncast_url() {
                    fetch('/owncast_url?channel=' + encodeURIComponent(this.channel))
                        .then(res => res.text())
                        .then(json => this.owncast_url = json);
                },
                async set_owncast_url(url) {
                    if (url.startsWith('http://')) {
                        url = url.replace('http://', '');
                    }
                    if (url.startsWith('https://')) {
                        url = url.replace('https://', '');
                    }
                    if (url.endsWith('/')) {
                        url = url.substr(0, url.length - 1);
                    }
                    this.set_channel_prop('owncast_url', url);
                },
                sanatize_kick_username(kick_username) {
                    if (kick_username.startsWith('http://')) {
                        kick_username = kick_username.replace('http://', '');
                    }
                    if (kick_username.startsWith('https://')) {
                        kick_username = kick_username.replace('https://', '');
                    }
                    if (kick_username.startsWith('kick.com/')) {
                        kick_username = kick_username.replace('kick.com/', '');
                    }
                    return kick_username;
                },
                async convert_kick_username_to_chatroom_id(kick_username) {
                    const res = await fetch('https://kick.com/api/v2/channels/' + kick_username);
                    return '' + (await res.json()).chatroom.id;
                },
                async kick_connect() {
                    const kick_username = this.sanatize_kick_username(this.kick_input);
                    this.set_channel_prop('kick_username', kick_username);
                    this.set_channel_prop('kick_chatroom_id', await this.convert_kick_username_to_chatroom_id(kick_username));
                },
                kick_disconnect() {
                    this.set_channel_prop('kick_username', undefined);
                    this.set_channel_prop('kick_chatroom_id', undefined);
                },
                check_twitch_status() {
                    fetch('/{{channel}}/status/twitch')
                        .then(res => res.text())
                        .then(text => {
                            console.log('/status/twitch', text);
                            alert(`Twitch Status:
${text}`);
                        });
                },
                check_youtube_status() {
                    fetch('/{{channel}}/status/youtube')
                        .then(res => res.json())
                        .then(json => {
                            console.log('/status/youtube', json);
                            alert(`YouTube Status:
channelId: ${json.listener?.channelId}
channelName: ${json.listener?.channelName}
videoId: ${json.listener?.videoId}
title: ${json.listener?.title}
isLive: ${json.listener?.isLive}`);
                        });
                },
                check_owncast_status() {
                    fetch('/{{channel}}/status/owncast')
                        .then(res => res.json())
                        .then(json => {
                            console.log('/status/owncast', json);
                            alert(`Owncast Status:
socket.servername: ${json.listener?.socket?.servername}
config.webSocketVersion: ${json.listener?.config?.webSocketVersion}`);
                        });
                },
                check_kick_status() {
                    fetch('/{{channel}}/status/kick')
                        .then(res => res.text())
                        .then(text => {
                            console.log('/status/kick', text);
                            alert(`Kick Status:
${text}`);
                        });
                },
                check_emotes_status() {
                    fetch('/{{channel}}/status/emotes')
                        .then(res => res.json())
                        .then(json => {
                            console.log('/status/emotes', json);
                            alert(`Emotes Status:
${JSON.stringify(json, undefined, 2)}`);
                        });
                },
                clear_chat() {
                    fetch_post('/{{channel}}/clear_chat');
                },
                async offboard(channel) {
                    if (confirm(`Are you sure you want to remove the bot from ${channel === this.login ? 'your' : 'this'} channel (${channel}) and delete all the data?`)) {
                        fetch('/api/offboard/' + channel)
                            .then(async res => {
                                const text = await res.text();
                                if (!res.ok) {
                                    console.log('status code:', res.status, 'text:', text);
                                    throw new Error(text);
                                }
                                window.location = '/';
                            })
                            .catch(error => {
                                console.error('offboard error:', error);
                                alert('offboarding failed: ' + error.message);
                            });
                    }
                },
                rem_quotes(s) {
                    return s?.replaceAll('"', '').replaceAll("'", '');
                },
                font_name(font) {
                    return this.rem_quotes(font?.split(',')[0]) ?? 'browser default';
                },
                save_font() {
                    if (this.channel_props_edit.font === 'custom') {
                        const new_font = prompt('Enter custom font name. Can specify multiple, separated by commas. If it has a space in the name, surround it in quotes, for example "Noto Sans":')?.trim();
                        if (!new_font) {
                            this.$nextTick(() => {
                                this.channel_props_edit.font = this.channel_props.font; //go back to old value (next tick cuz this is already the @change)
                            });
                            return;
                        } else {
                            this.channel_props_edit.font = new_font;
                        }
                    }
                    this.save_channel_prop('font');
                },
                save_text_shadow() {
                    if (this.channel_props_edit.text_shadow === 'custom') {
                        const new_text_shadow = prompt('Enter custom CSS for text_shadow. For reference, see this page: https://developer.mozilla.org/en-US/docs/Web/CSS/text-shadow')?.trim();
                        if (!new_text_shadow) {
                            this.$nextTick(() => {
                                this.channel_props_edit.text_shadow = this.channel_props.text_shadow; //go back to old value (next tick cuz this is already the @change)
                            });
                            return;
                        } else {
                            this.channel_props_edit.text_shadow = new_text_shadow;
                        }
                    }
                    this.save_channel_prop('text_shadow');
                },
                async detect_used_font(selector) {
                    await document.fonts.ready; //wait for the font to be applied fully
                    const element = document.querySelector(selector);
                    const computed_style = window.getComputedStyle(element);
                    const fonts = computed_style.fontFamily.split(',').map(font => font.trim());

                    const browser_computed_style = window.getComputedStyle(document.querySelector('body'));

                    //test element for measuring font width/height
                    const test = document.querySelector('#font_test');

                    //get initial dimensions with the browser's default font stack
                    test.style.fontFamily = browser_computed_style.fontFamily;
                    const browser_width = test.offsetWidth;
                    const browser_height = test.offsetHeight;

                    //get initial dimensions with the full font stack
                    test.style.fontFamily = computed_style.fontFamily;
                    const full_width = test.offsetWidth;
                    const full_height = test.offsetHeight;

                    //if the width and height with the full stack are the same as the browser font,
                    //assume none of the fonts worked and it is the browser font
                    if (full_width === browser_width && full_height === browser_height) {
                        return browser_computed_style.fontFamily;
                    }

                    //compare with each font individually
                    for (const font of fonts) {
                        test.style.fontFamily = font;
                        if (test.offsetWidth === full_width && test.offsetHeight === full_height) {
                            return this.rem_quotes(font);
                        }
                    }

                    return null;
                },

            },
            mounted() {
                this.websocket_connect();
                fetch('/{{channel}}/viewers')
                    .then(res => res.json())
                    .then(json => this.viewers = json);
                fetch('/{{channel}}/chat_history')
                    .then(res => res.json())
                    .then(json => {
                        json.forEach(msg => this.websocket_chat(msg));
                    });

                for (const prop_name of Object.keys(this.channel_props)) {
                    this.get_channel_prop(prop_name);
                }
            },
            watch: {
                channel(new_channel, old_channel) {
                    window.location = '/' + new_channel;
                },
                'channel_props.font': {
                    handler: async function (new_font, old_font) {
                        this.actual_font = await this.detect_used_font('#container');
                    },
                    immediate: true
                },
            },
            computed: {
                is_onboarded() {
                    return this.channels.includes(this.login);
                },
                is_auth() {
                    return this.is_logged_in && this.channel === this.login || this.is_super_admin;
                }
            },
        }).mount('#app');
    </script>
</body>

</html>